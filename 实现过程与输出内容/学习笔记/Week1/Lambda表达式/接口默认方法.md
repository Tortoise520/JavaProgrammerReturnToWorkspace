# 接口默认方法
在 Java 中，Lambda 表达式和接口的默认方法是 Java 8 引入的两个重要特性，它们经常一起使用。让我详细解释这两者以及它们之间的关系。

## 1. Lambda 表达式基础

Lambda 表达式主要用于实现函数式接口（只有一个抽象方法的接口）。

```java
// 传统方式
Runnable runnable1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("传统方式");
    }
};

// Lambda 方式
Runnable runnable2 = () -> System.out.println("Lambda方式");
```

## 2. 接口默认方法

默认方法允许在接口中提供方法实现，而不会破坏现有的实现类。

```java
interface Vehicle {
    // 抽象方法
    void start();
    
    // 默认方法
    default void honk() {
        System.out.println("车辆鸣笛");
    }
    
    // 静态方法
    static void service() {
        System.out.println("车辆保养");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("汽车启动");
    }
    
    // 可以选择重写默认方法，但不是必须的
}
```

## 3. Lambda 与默认方法的结合使用

### 示例 1：函数式接口带默认方法

```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    default String getOperator() {
        return "未知运算符";
    }
    
    static void printVersion() {
        System.out.println("计算器 v1.0");
    }
}

public class LambdaWithDefaultMethod {
    public static void main(String[] args) {
        // 使用 Lambda 实现抽象方法
        Calculator addition = (a, b) -> a + b;
        
        // 调用抽象方法
        System.out.println("5 + 3 = " + addition.calculate(5, 3));
        
        // 调用默认方法
        System.out.println("运算符: " + addition.getOperator());
        
        // 调用静态方法
        Calculator.printVersion();
    }
}
```

### 示例 2：更复杂的例子

```java
interface StringProcessor {
    // 抽象方法
    String process(String input);
    
    // 默认方法
    default StringProcessor andThen(StringProcessor after) {
        return input -> after.process(this.process(input));
    }
    
    default StringProcessor toUpperCase() {
        return andThen(input -> input.toUpperCase());
    }
    
    default StringProcessor toLowerCase() {
        return andThen(input -> input.toLowerCase());
    }
    
    // 静态方法
    static StringProcessor identity() {
        return input -> input;
    }
}

public class ProcessorExample {
    public static void main(String[] args) {
        StringProcessor trimProcessor = input -> input.trim();
        StringProcessor reverseProcessor = input -> 
            new StringBuilder(input).reverse().toString();
        
        // 组合多个处理器
        StringProcessor pipeline = trimProcessor
            .andThen(reverseProcessor)
            .toUpperCase();
        
        String result = pipeline.process("  hello world  ");
        System.out.println("结果: " + result); // 输出: DLROW OLLEH
    }
}
```

## 4. 实际应用场景

### 场景 1：集合操作

```java
import java.util.*;
import java.util.function.*;

public class CollectionExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // 使用 Lambda 和默认方法
        names.stream()
            .filter(name -> name.length() > 3)  // Lambda
            .map(String::toUpperCase)           // 方法引用
            .sorted()                           // 默认方法
            .forEach(System.out::println);      // 默认方法
    }
}
```

### 场景 2：自定义函数式接口

```java
@FunctionalInterface
interface Validator<T> {
    boolean validate(T value);
    
    default Validator<T> and(Validator<T> other) {
        return value -> this.validate(value) && other.validate(value);
    }
    
    default Validator<T> or(Validator<T> other) {
        return value -> this.validate(value) || other.validate(value);
    }
    
    static <T> Validator<T> notNull() {
        return value -> value != null;
    }
}

public class ValidatorExample {
    public static void main(String[] args) {
        Validator<String> notNull = Validator.notNull();
        Validator<String> notEmpty = value -> !value.isEmpty();
        Validator<String> lengthValidator = value -> value.length() >= 5;
        
        // 组合验证器
        Validator<String> combined = notNull
            .and(notEmpty)
            .and(lengthValidator);
        
        System.out.println(combined.validate("Hello"));  // true
        System.out.println(combined.validate("Hi"));     // false
    }
}
```

## 5. 注意事项

### 默认方法冲突解决

```java
interface A {
    default void show() {
        System.out.println("接口A");
    }
}

interface B {
    default void show() {
        System.out.println("接口B");
    }
}

class C implements A, B {
    // 必须重写冲突的默认方法
    @Override
    public void show() {
        // 可以选择调用特定接口的默认方法
        A.super.show();
        // 或者提供自己的实现
        System.out.println("类C的实现");
    }
}
```

### 函数式接口规则

```java
// 这是函数式接口（只有一个抽象方法）
@FunctionalInterface
interface FunctionalExample {
    void abstractMethod();
    
    default void defaultMethod() {
        System.out.println("默认方法");
    }
    
    static void staticMethod() {
        System.out.println("静态方法");
    }
}

// 这不是函数式接口（有多个抽象方法）
interface NonFunctionalExample {
    void method1();
    void method2();  // 编译错误：多个抽象方法
}
```

## 总结

- **Lambda 表达式**：用于简洁地实现函数式接口的抽象方法
- **默认方法**：允许在接口中提供方法实现，增强接口的扩展性
- **两者结合**：可以创建更灵活、可组合的 API
- **静态方法**：在接口中提供工具方法

这种组合让 Java 能够更好地支持函数式编程范式，同时保持向后兼容性。