## 方法引用
当然，我们来详细讲解一下 Java 中 Lambda 表达式的一个重要特性——**方法引用（Method Reference）**。

方法引用是一种特殊的 Lambda 表达式，它允许你直接引用一个已经存在的方法。当 Lambda 表达式的主体仅仅是通过名字来**调用一个已有的方法**时，就可以使用方法引用，这使得代码更加简洁、清晰。

---

### 1. 为什么需要方法引用？

先看一个简单的 Lambda 表达式例子：

```java
List<String> list = Arrays.asList("a", "b", "c");
list.forEach(s -> System.out.println(s));
```

在这个例子中，Lambda 表达式 `s -> System.out.println(s)` 仅仅是将其参数 `s` 传递给 `System.out.println` 方法。这种情况下，就可以使用方法引用进行简化：

```java
list.forEach(System.out::println);
```

可以看到，方法引用 `System.out::println` 比原始的 Lambda 表达式更简洁，意图也更明确。

---

### 2. 方法引用的语法

方法引用的语法是：`目标引用 :: 方法名`。

它不关心方法的参数和返回类型，编译器会根据上下文（即函数式接口）自动推断。

---

### 3. 方法引用的四种类型

方法引用主要有四种形式：

#### 3.1 引用静态方法（`Class::staticMethod`）

语法：`类名 :: 静态方法名`

**示例：** 将字符串转换为整数
```java
// Lambda 表达式
Function<String, Integer> converter1 = s -> Integer.parseInt(s);

// 方法引用
Function<String, Integer> converter2 = Integer::parseInt;

System.out.println(converter2.apply("123")); // 输出：123
```

**示例：** 求一个数的绝对值
```java
// Lambda 表达式
Function<Integer, Integer> abs1 = x -> Math.abs(x);

// 方法引用
Function<Integer, Integer> abs2 = Math::abs;

System.out.println(abs2.apply(-10)); // 输出：10
```

#### 3.2 引用特定对象的实例方法（`instance::instanceMethod`）

语法：`对象实例 :: 实例方法名`

**示例：** 判断字符串是否为空
```java
String str = "Hello";
// Lambda 表达式
Predicate<String> isEmpty1 = s -> str.isEmpty();

// 方法引用 (引用一个已存在的特定对象 `str` 的方法)
Predicate<String> isEmpty2 = str::isEmpty;

System.out.println(isEmpty2.test("")); // 输出：false (因为str是"Hello")
```

**示例：** 设置一个名字格式化规则
```java
String prefix = "Mr. ";
// Lambda 表达式
Function<String, String> addPrefix1 = name -> prefix.concat(name);

// 方法引用
Function<String, String> addPrefix2 = prefix::concat;

System.out.println(addPrefix2.apply("Smith")); // 输出：Mr. Smith
```

#### 3.3 引用特定类型的任意对象的实例方法（`Class::instanceMethod`）

这种形式比较特殊。当 Lambda 表达式的第一个参数是调用实例方法的对象，其余参数是该实例方法的参数时，可以使用这种引用。

语法：`类名 :: 实例方法名`

**示例：** 比较两个字符串
```java
// Lambda 表达式
BiFunction<String, String, Boolean> comparator1 = (s1, s2) -> s1.equals(s2);

// 方法引用 (第一个参数 s1 成为 equals 方法的调用者)
BiFunction<String, String, Boolean> comparator2 = String::equals;

System.out.println(comparator2.apply("hello", "hello")); // 输出：true
```

**示例：** 获取字符串的长度
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Lambda 表达式
List<Integer> lengths1 = names.stream().map(s -> s.length()).collect(Collectors.toList());

// 方法引用 (流中的每一个 String 对象，都调用其自身的 length() 方法)
List<Integer> lengths2 = names.stream().map(String::length).collect(Collectors.toList());

System.out.println(lengths2); // 输出：[5, 3, 7]
```

#### 3.4 引用构造方法（`Class::new`）

语法：`类名 :: new`

**示例：** 创建一个字符串列表
```java
// Lambda 表达式
Supplier<List<String>> supplier1 = () -> new ArrayList<>();

// 方法引用
Supplier<List<String>> supplier2 = ArrayList::new;

List<String> list = supplier2.get();
```

**示例：** 使用带参数的构造方法
```java
// Lambda 表达式
Function<String, Integer> creator1 = s -> new Integer(s);

// 方法引用
Function<String, Integer> creator2 = Integer::new;

System.out.println(creator2.apply("456")); // 输出：456
```

**示例：** 引用有多个参数的构造方法
```java
// 假设有一个 Person 类，构造方法为 Person(String name, int age)
BiFunction<String, Integer, Person> personCreator1 = (name, age) -> new Person(name, age);

// 方法引用
BiFunction<String, Integer, Person> personCreator2 = Person::new;

Person p = personCreator2.apply("Tom", 25);
```

---

### 4. 总结与对比

| 场景 | Lambda 表达式 | 方法引用 |
| :--- | :--- | :--- |
| 调用静态方法 | `s -> Integer.parseInt(s)` | `Integer::parseInt` |
| 调用特定对象的实例方法 | `s -> myObject.myMethod(s)` | `myObject::myMethod` |
| 调用任意对象的实例方法 | `(a, b) -> a.compareTo(b)` | `String::compareTo` |
| 调用构造方法 | `() -> new ArrayList<>()` | `ArrayList::new` |

**核心优点：**
1.  **简洁性**：代码更短，更易读。
2.  **可读性**：直接看到被调用的方法名，意图明确。
3.  **可维护性**：减少了模板代码。

**何时使用？**
当你的 Lambda 表达式仅仅是“传递参数给一个方法调用”时，就应该毫不犹豫地使用方法引用。它是将 Lambda 表达式推向更高简洁度和表达力的重要工具。